import { EMPTY, fromEvent, of, race, Subject, timer } from 'rxjs';
import { endWith, filter, takeUntil } from 'rxjs/operators';
import { getTransitionDurationMs } from './util';
import { environment } from '../../environment';
import { reflow } from '../util';
const noopFn = () => { };
const ɵ0 = noopFn;
const { transitionTimerDelayMs } = environment;
const runningTransitions = new Map();
export const ngbRunTransition = (element, startFn, options) => {
    // Getting initial context from options
    let context = options.context || {};
    // Checking if there are already running transitions on the given element.
    const running = runningTransitions.get(element);
    if (running) {
        switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
                return EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.
            case 'stop':
                running.transition$.complete();
                context = Object.assign(running.context, context);
                runningTransitions.delete(element);
        }
    }
    // A reflow is required here, to be sure that everything is ready,
    // Without reflow, the transition will not be started for some widgets, at initialization time
    reflow(element);
    const endFn = startFn(element, context) || noopFn;
    // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
    // If animations are disabled, we have to emit a value and complete the observable
    // In this case we have to call the end function, but can finish immediately by emitting a value,
    // completing the observable and executing end functions synchronously.
    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        endFn();
        return of(undefined);
    }
    // Starting a new transition
    const transition$ = new Subject();
    const finishTransition$ = new Subject();
    const stop$ = transition$.pipe(endWith(true));
    runningTransitions.set(element, {
        transition$,
        complete: () => {
            finishTransition$.next();
            finishTransition$.complete();
        },
        context
    });
    const transitionDurationMs = getTransitionDurationMs(element);
    // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
    // because 'transitionend' event might not be fired in some browsers, if the transitioning
    // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
    // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
    // 2. We need to filter transition end events, because they might bubble from shorter transitions
    // on inner DOM elements. We're only interested in the transition on the 'element' itself.
    const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({ target }) => target === element));
    const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));
    race(timer$, transitionEnd$, finishTransition$).pipe(takeUntil(stop$)).subscribe(() => {
        runningTransitions.delete(element);
        endFn();
        transition$.next();
        transition$.complete();
    });
    return transition$.asObservable();
};
export const ngbCompleteTransition = (element) => {
    var _a;
    (_a = runningTransitions.get(element)) === null || _a === void 0 ? void 0 : _a.complete();
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdiVHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvbW9rb3Jva292L0Rldi9Bbmd1bGFyL2NvcmUvc3JjLyIsInNvdXJjZXMiOlsidXRpbC90cmFuc2l0aW9uL25nYlRyYW5zaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzVFLE9BQU8sRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzFELE9BQU8sRUFBQyx1QkFBdUIsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUMvQyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFNBQVMsQ0FBQztBQWlCL0IsTUFBTSxNQUFNLEdBQXVCLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQzs7QUFFNUMsTUFBTSxFQUFDLHNCQUFzQixFQUFDLEdBQUcsV0FBVyxDQUFDO0FBQzdDLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQXNDLENBQUM7QUFFekUsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQ3pCLENBQUksT0FBb0IsRUFBRSxPQUFnQyxFQUFFLE9BQWdDLEVBQ2xFLEVBQUU7SUFFdEIsdUNBQXVDO0lBQ3ZDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQU8sRUFBRSxDQUFDO0lBRXZDLDBFQUEwRTtJQUMxRSxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEQsSUFBSSxPQUFPLEVBQUU7UUFDWCxRQUFRLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtZQUNqQyxrR0FBa0c7WUFDbEcsK0VBQStFO1lBQy9FLEtBQUssVUFBVTtnQkFDYixPQUFPLEtBQUssQ0FBQztZQUNmLDZGQUE2RjtZQUM3Rix5R0FBeUc7WUFDekcseURBQXlEO1lBQ3pELEtBQUssTUFBTTtnQkFDVCxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUMvQixPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRCxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEM7S0FDRjtJQUVELGtFQUFrRTtJQUNsRSw4RkFBOEY7SUFDOUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRWhCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDO0lBRWxELGlGQUFpRjtJQUNqRixrRkFBa0Y7SUFDbEYsaUdBQWlHO0lBQ2pHLHVFQUF1RTtJQUN2RSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsa0JBQWtCLEtBQUssTUFBTSxFQUFFO1FBQ3hGLEtBQUssRUFBRSxDQUFDO1FBQ1IsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDdEI7SUFFRCw0QkFBNEI7SUFDNUIsTUFBTSxXQUFXLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztJQUN2QyxNQUFNLGlCQUFpQixHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7SUFDN0MsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM5QyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFO1FBQzlCLFdBQVc7UUFDWCxRQUFRLEVBQUUsR0FBRyxFQUFFO1lBQ2IsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDekIsaUJBQWlCLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsQ0FBQztRQUNELE9BQU87S0FDUixDQUFDLENBQUM7SUFFSCxNQUFNLG9CQUFvQixHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTlELDJGQUEyRjtJQUMzRiwwRkFBMEY7SUFDMUYsK0ZBQStGO0lBQy9GLGtGQUFrRjtJQUNsRixpR0FBaUc7SUFDakcsMEZBQTBGO0lBQzFGLE1BQU0sY0FBYyxHQUNoQixTQUFTLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBQyxNQUFNLEVBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDekcsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixHQUFHLHNCQUFzQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRTNGLElBQUksQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDcEYsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25DLEtBQUssRUFBRSxDQUFDO1FBQ1IsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ25CLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sV0FBVyxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ3BDLENBQUMsQ0FBQztBQUVWLE1BQU0sQ0FBQyxNQUFNLHFCQUFxQixHQUFHLENBQUMsT0FBb0IsRUFBRSxFQUFFOztJQUM1RCxNQUFBLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsMENBQUcsUUFBUSxHQUFHO0FBQy9DLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RU1QVFksIGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgb2YsIHJhY2UsIFN1YmplY3QsIHRpbWVyfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZW5kV2l0aCwgZmlsdGVyLCB0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7Z2V0VHJhbnNpdGlvbkR1cmF0aW9uTXN9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge2Vudmlyb25tZW50fSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQge3JlZmxvd30gZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCB0eXBlIE5nYlRyYW5zaXRpb25TdGFydEZuPFQgPSBhbnk+ID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb250ZXh0OiBUKSA9PiBOZ2JUcmFuc2l0aW9uRW5kRm4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgTmdiVHJhbnNpdGlvbkVuZEZuID0gKCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBOZ2JUcmFuc2l0aW9uT3B0aW9uczxUPiB7XG4gIGFuaW1hdGlvbjogYm9vbGVhbjtcbiAgcnVubmluZ1RyYW5zaXRpb246ICdjb250aW51ZScgfCAnc3RvcCc7XG4gIGNvbnRleHQ/OiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5nYlRyYW5zaXRpb25DdHg8VD4ge1xuICB0cmFuc2l0aW9uJDogU3ViamVjdDxhbnk+O1xuICBjb21wbGV0ZTogKCkgPT4gdm9pZDtcbiAgY29udGV4dDogVDtcbn1cblxuY29uc3Qgbm9vcEZuOiBOZ2JUcmFuc2l0aW9uRW5kRm4gPSAoKSA9PiB7fTtcblxuY29uc3Qge3RyYW5zaXRpb25UaW1lckRlbGF5TXN9ID0gZW52aXJvbm1lbnQ7XG5jb25zdCBydW5uaW5nVHJhbnNpdGlvbnMgPSBuZXcgTWFwPEhUTUxFbGVtZW50LCBOZ2JUcmFuc2l0aW9uQ3R4PGFueT4+KCk7XG5cbmV4cG9ydCBjb25zdCBuZ2JSdW5UcmFuc2l0aW9uID1cbiAgICA8VD4oZWxlbWVudDogSFRNTEVsZW1lbnQsIHN0YXJ0Rm46IE5nYlRyYW5zaXRpb25TdGFydEZuPFQ+LCBvcHRpb25zOiBOZ2JUcmFuc2l0aW9uT3B0aW9uczxUPik6XG4gICAgICAgIE9ic2VydmFibGU8dW5kZWZpbmVkPiA9PiB7XG5cbiAgICAgICAgICAvLyBHZXR0aW5nIGluaXRpYWwgY29udGV4dCBmcm9tIG9wdGlvbnNcbiAgICAgICAgICBsZXQgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCA8VD57fTtcblxuICAgICAgICAgIC8vIENoZWNraW5nIGlmIHRoZXJlIGFyZSBhbHJlYWR5IHJ1bm5pbmcgdHJhbnNpdGlvbnMgb24gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgICAgY29uc3QgcnVubmluZyA9IHJ1bm5pbmdUcmFuc2l0aW9ucy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5ydW5uaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmUgcnVubmluZyBhbmQgd2Ugd2FudCBmb3IgaXQgdG8gJ2NvbnRpbnVlJyB0byBydW4sIHdlIGhhdmUgdG8gY2FuY2VsIHRoZSBuZXcgb25lLlxuICAgICAgICAgICAgICAvLyBXZSdyZSBub3QgZW1pdHRpbmcgYW55IHZhbHVlcywgYnV0IHNpbXBseSBjb21wbGV0aW5nIHRoZSBvYnNlcnZhYmxlIChFTVBUWSkuXG4gICAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9uZSBydW5uaW5nIGFuZCB3ZSB3YW50IGZvciBpdCB0byAnc3RvcCcsIHdlIGhhdmUgdG8gY29tcGxldGUgdGhlIHJ1bm5pbmcgb25lLlxuICAgICAgICAgICAgICAvLyBXZSdyZSBzaW1wbHkgY29tcGxldGluZyB0aGUgcnVubmluZyBvbmUgYW5kIG5vdCBlbWl0dGluZyBhbnkgdmFsdWVzIGFuZCBtZXJnaW5nIG5ld2x5IHByb3ZpZGVkIGNvbnRleHRcbiAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgb25lIGNvbWluZyBmcm9tIGN1cnJlbnRseSBydW5uaW5nIHRyYW5zaXRpb24uXG4gICAgICAgICAgICAgIGNhc2UgJ3N0b3AnOlxuICAgICAgICAgICAgICAgIHJ1bm5pbmcudHJhbnNpdGlvbiQuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbihydW5uaW5nLmNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdUcmFuc2l0aW9ucy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSByZWZsb3cgaXMgcmVxdWlyZWQgaGVyZSwgdG8gYmUgc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVhZHksXG4gICAgICAgICAgLy8gV2l0aG91dCByZWZsb3csIHRoZSB0cmFuc2l0aW9uIHdpbGwgbm90IGJlIHN0YXJ0ZWQgZm9yIHNvbWUgd2lkZ2V0cywgYXQgaW5pdGlhbGl6YXRpb24gdGltZVxuICAgICAgICAgIHJlZmxvdyhlbGVtZW50KTtcblxuICAgICAgICAgIGNvbnN0IGVuZEZuID0gc3RhcnRGbihlbGVtZW50LCBjb250ZXh0KSB8fCBub29wRm47XG5cbiAgICAgICAgICAvLyBJZiAncHJlZmVyLXJlZHVjZWQtbW90aW9uJyBpcyBlbmFibGVkLCB0aGUgJ3RyYW5zaXRpb24nIHdpbGwgYmUgc2V0IHRvICdub25lJy5cbiAgICAgICAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBkaXNhYmxlZCwgd2UgaGF2ZSB0byBlbWl0IGEgdmFsdWUgYW5kIGNvbXBsZXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gY2FsbCB0aGUgZW5kIGZ1bmN0aW9uLCBidXQgY2FuIGZpbmlzaCBpbW1lZGlhdGVseSBieSBlbWl0dGluZyBhIHZhbHVlLFxuICAgICAgICAgIC8vIGNvbXBsZXRpbmcgdGhlIG9ic2VydmFibGUgYW5kIGV4ZWN1dGluZyBlbmQgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmFuaW1hdGlvbiB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS50cmFuc2l0aW9uUHJvcGVydHkgPT09ICdub25lJykge1xuICAgICAgICAgICAgZW5kRm4oKTtcbiAgICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgbmV3IHRyYW5zaXRpb25cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uJCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICAgICAgICBjb25zdCBmaW5pc2hUcmFuc2l0aW9uJCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICAgICAgICBjb25zdCBzdG9wJCA9IHRyYW5zaXRpb24kLnBpcGUoZW5kV2l0aCh0cnVlKSk7XG4gICAgICAgICAgcnVubmluZ1RyYW5zaXRpb25zLnNldChlbGVtZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uJCxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGZpbmlzaFRyYW5zaXRpb24kLm5leHQoKTtcbiAgICAgICAgICAgICAgZmluaXNoVHJhbnNpdGlvbiQuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25NcyA9IGdldFRyYW5zaXRpb25EdXJhdGlvbk1zKGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gMS4gV2UgaGF2ZSB0byBib3RoIGxpc3RlbiBmb3IgdGhlICd0cmFuc2l0aW9uZW5kJyBldmVudCBhbmQgaGF2ZSBhICdqdXN0LWluLWNhc2UnIHRpbWVyLFxuICAgICAgICAgIC8vIGJlY2F1c2UgJ3RyYW5zaXRpb25lbmQnIGV2ZW50IG1pZ2h0IG5vdCBiZSBmaXJlZCBpbiBzb21lIGJyb3dzZXJzLCBpZiB0aGUgdHJhbnNpdGlvbmluZ1xuICAgICAgICAgIC8vIGVsZW1lbnQgYmVjb21lcyBpbnZpc2libGUgKGV4LiB3aGVuIHNjcm9sbGluZywgbWFraW5nIGJyb3dzZXIgdGFiIGluYWN0aXZlLCBldGMuKS4gVGhlIHRpbWVyXG4gICAgICAgICAgLy8gZ3VhcmFudGVlcywgdGhhdCB3ZSdsbCByZWxlYXNlIHRoZSBET00gZWxlbWVudCBhbmQgY29tcGxldGUgJ25nYlJ1blRyYW5zaXRpb24nLlxuICAgICAgICAgIC8vIDIuIFdlIG5lZWQgdG8gZmlsdGVyIHRyYW5zaXRpb24gZW5kIGV2ZW50cywgYmVjYXVzZSB0aGV5IG1pZ2h0IGJ1YmJsZSBmcm9tIHNob3J0ZXIgdHJhbnNpdGlvbnNcbiAgICAgICAgICAvLyBvbiBpbm5lciBET00gZWxlbWVudHMuIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgdHJhbnNpdGlvbiBvbiB0aGUgJ2VsZW1lbnQnIGl0c2VsZi5cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRW5kJCA9XG4gICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpLnBpcGUodGFrZVVudGlsKHN0b3AkKSwgZmlsdGVyKCh7dGFyZ2V0fSkgPT4gdGFyZ2V0ID09PSBlbGVtZW50KSk7XG4gICAgICAgICAgY29uc3QgdGltZXIkID0gdGltZXIodHJhbnNpdGlvbkR1cmF0aW9uTXMgKyB0cmFuc2l0aW9uVGltZXJEZWxheU1zKS5waXBlKHRha2VVbnRpbChzdG9wJCkpO1xuXG4gICAgICAgICAgcmFjZSh0aW1lciQsIHRyYW5zaXRpb25FbmQkLCBmaW5pc2hUcmFuc2l0aW9uJCkucGlwZSh0YWtlVW50aWwoc3RvcCQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgcnVubmluZ1RyYW5zaXRpb25zLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGVuZEZuKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uJC5uZXh0KCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uJC5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24kLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9O1xuXG5leHBvcnQgY29uc3QgbmdiQ29tcGxldGVUcmFuc2l0aW9uID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XG4gIHJ1bm5pbmdUcmFuc2l0aW9ucy5nZXQoZWxlbWVudCkgPy5jb21wbGV0ZSgpO1xufTtcbiJdfQ==